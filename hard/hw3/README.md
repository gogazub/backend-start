# Строим дальше

## Не спать на POSTу! :)

На паре мы поговорили про брокеры сообщений. Вам 5 секунд на то, чтобы понять - куда его впихнуть!
Так вот, давайте попробуем теперь посылать запросы в `RabbitMQ` + напишем `Consumer'a` - и назовем его `{Image/Code}Processor` -
в зависимости от того, какой проект вы выбрали.

Что же должен делать `Consumer`?

### CodeProcessor

Чужой код нужно запускать в изолированной среде - лучше всего для этого подойдет `Docker`. Нам нужно заранее заготовить `Dockerfile`, в котором будет запускаться код. Давайте его создадим в отдельной папке процессора и скачаем туда пару базовых компиляторов: clang, gcc, и еще интерпретатор: python. Дальше с помощью библиотеки для каждой новой поссылки будем создавать докер контейнер - класть создавать внутри файл с пользовательским кодом, компилировать его, если требуется и запускать. В качестве результата мы будем брать `stdout`, `stderr` пользователя.

### ImageProcessor

Получаем картинку (допустим, в формате png) - а далее делаем с ней все, что хотим! Можно добавить следующие фильтры из библиотеки: `Sharpen`, `Blur`. Также, два простеньких попробовать написать самому - `Negative`, `Отображение относительно оси X`. Как можно заметить фильтры - `Sharpen`, `Blur` имеют входной параметр, поэтому наш `JSON` с указанием фильтра теперь будет выглядеть так: `{"filter": {"name": <string>, "parameters": <json>}}`. В качестве результата будет измененная картинка.

## Коммит

Куда положить результат выполнения `Consumer'ов`? Лучше всего это сделать в базу напрямую, но пока мы не знаем, что это такое, если бы мы знали что это такое... Давайте пока что в виде временного решения обойдемся просто ручкой `/commit` у нашего HTTP сервера, для того, чтобы тесты работали. (В случае с картинкой нужно сделать так, чтобы картинка отображалась в браузере при запросе /result)

## Запускаем все вместе

Напишите `docker-compose` файл для запуска `HTTP` сервера, `RabbitMQ`, `Processor`'a (обратите внимание, что `Processor` это отдельный микросервис и соответственно он должен быть в отдельном бинарнике и отдельном Dockerfile) .
Прокиньте туда файл `tests.py`. Настройте `Makefile`. Далее напишите CI процесс с помощью GitHub Actions, о котором было сказано на Лекции #4 и сдайте это соответствующему куратору в отдельной ветке. Убедитесь, что горят зеленые галочки, а не красные крестики (это вам не наша раша)

# Материалы

[RabbitMQ](https://www.rabbitmq.com/tutorials)  
[Фильтры для ImageProcessor'a на Golang](https://github.com/disintegration/imaging)  
[Клиент докера для CodeProcessor'a на Golang](https://github.com/moby/moby)  
  
